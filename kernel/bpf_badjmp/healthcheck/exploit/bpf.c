// SPDX-License-Identifier: Apache-2.0
/*
 * Copyright 2021 Google LLC.
 */

#include <assert.h>
#include <sys/socket.h>
#include <unistd.h>

#include <bpf/bpf.h>

#include "bpf.skel.h"

static struct bpf_bpf *obj;
static int prog_fd;
static int sktpair[2];

static void perror_exit(char *msg)
{
	perror(msg);
	exit(1);
}

static long read_primitive(uintptr_t addr)
{
	char msg[] = "FOO";
	int key = 0;
	long value = addr;

	if (bpf_map_update_elem(bpf_map__fd(obj->maps.communicate), &key, &value, 0) < 0)
		perror_exit("bpf_map_lookup_elem");

	if (write(sktpair[1], msg, sizeof(msg)) != sizeof(msg))
		perror_exit("write");

	(void)!read(sktpair[0], msg, sizeof(msg));

	if (bpf_map_lookup_elem(bpf_map__fd(obj->maps.communicate), &key, &value) < 0)
		perror_exit("bpf_map_lookup_elem");

	return value;
}

static void dump_str(uintptr_t kptr)
{
	while (true) {
		union {
			uint32_t u32;
			char str[4];
		} u;
		u.u32 = read_primitive(kptr);

		for (int i = 0; i < 4; i++) {
			if (!u.str[i])
				return;

			putchar(u.str[i]);
		}

		kptr += 4;
	}
}

int main(int argc, char **argv)
{
	uintptr_t kptr;

	if (argc < 2) {
		fprintf(stderr, "Usage: %s [hex address]\n", argv[0]);
		exit(1);
	}

	sscanf(argv[1], "%zx", &kptr);

	obj = bpf_bpf__open_and_load();
	if (!obj)
		exit(1);

	prog_fd = bpf_program__fd(obj->progs.prog);
	assert(prog_fd >= 0);

	if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sktpair) < 0)
		perror_exit("socketpair");

	if (setsockopt(sktpair[0], SOL_SOCKET, SO_ATTACH_BPF,
		       &prog_fd, sizeof(prog_fd)) < 0)
		perror_exit("sktpair");

	dump_str(kptr);

	return 0;
}
